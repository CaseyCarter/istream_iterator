---
pagetitle: Coroutine generator
title: Coroutine `generator`
...

### Abstract

This paper proposes a `generator` coroutine type which can be used to quickly and easily implement single-pass ranges.

### Revision history
#### Revision 0
* XXX FIXME XXX

### Motivation

Support for ranges in C++ has recently been rapidly improving. The Ranges TS was published in November 2017, adding fundamental support for ranges in the Standard Library. There are proposals underway to merge Ranges into the C++20 working paper (P0898 and P0896 and P1037) to extend coverage for ranges to different parts of the Standard Library (P1033) and to provide a library of view adaptors (P0789) that can be easily composed to derive complex range computations from basic building blocks. Despite the existence of proposals (P0186 and P0789) to provide utilities to ease the authoring of primary ranges, doing so is still a task primarily for experts: there are many fiddly details necessary to implement conforming iterators and to link an iterator and range implementation.

Many other programming languages provide facilities for the implementation of *range generators*: coroutines that yield multiple values and present themselves as ranges. In Python, for example, one can trivially implement a function with a single integer parameter `n` that returns a range generator which enumerates the integers from `0` to `n`:
```
>>> def numbers(n):
...   for i in range(n): yield i
...
>>> for i in numbers(4): print i
...
0
1
2
3
```
Given that C++ also recently published a TS for coroutines (ISO/IEC TS 22277:2017), the time seems ripe to add a facility for coroutine generators to C++ as well.

Despite that C++ has no generators, the notion of generating a range from a function is not entirely foreign. The `generate` and `generate_n` algorithms have always been present in Standard C++. Authoring stateful functions for use with these algorithms is much like authoring ranges: a programmer factors out state to be stored in a range / iterator, and updates that state on every call to a function. This "external state and single-iteration function" paradigm is equivalent in expressive power to the coroutine generator paradigm, but the coroutine generator has a vastly simpler programming model: you simply generate each of the values in your range in order and `yield` them.

#### Tony Table

How might we implement `numbers` in C++? For contrast, here are implementations using:
* Standard C++ with no additional helpers,
* All of the high-level range implementation facilities in `range-v3` (many of which will eventually be proposed for standardization),
* This proposal.

| Standard C++ | range-v3 | generator |
| :--- | :--- | :--- |
| `struct numbers`<br>`{`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`numbers() = default;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`explicit numbers(int bound)`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`: bound_{bound}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{}`<br><br>`private:`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int bound_ = 0;`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`struct iterator {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`using iterator_category =`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`ranges::forward_iterator_tag;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`using value_type = int;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`using difference_type = int;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`using reference = int;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`using pointer = void;`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`iterator() = default;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`explicit iterator(int pos)`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`: pos_{pos}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{}`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int operator*() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return pos_;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`friend bool operator==(iterator x, iterator y) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return x.pos_ == y.pos_;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`friend bool operator!=(iterator x, iterator y) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return !(x == y);`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`iterator& operator++() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`++pos_;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return *this;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`iterator operator++(int) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`auto tmp = *this;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`++*this;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return tmp;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`private:`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int pos_ = 0;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`};`<br>`public:`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`auto begin() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return iterator{0};`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`auto end() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return iterator{bound_};`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>`};` | `struct numbers`<br>&nbsp;&nbsp;&nbsp;&nbsp;`: ranges::view_facade<numbers>`<br>`{`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`friend ranges::range_access;`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`numbers() = default;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`explicit numbers(int bound)`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`: bound_{bound}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{}`<br><br>`private:`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int bound_ = 0;`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`struct cursor {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`cursor() = default;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`explicit cursor(int pos)`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`: pos_{pos}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{}`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int read() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return pos_;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`bool equal(cursor x) const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return pos_ == x.pos_;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`void next() { ++pos_; }`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`private:`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`int pos_ = 0;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`};`<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`auto begin_cursor() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return cursor{0};`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`auto end_cursor() const {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return cursor{bound_};`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>`};` | `generator<int> numbers(int n) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`for (auto i = 0; i < n; ++i) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`co_yield i;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>`}` |

This document isn't a range authoring tutorial, so we want explain how these examples work in detail, but note that the `generator` example is *an order of magnitude* more concise than the other two. The line counts are respectively 51, 37, and 5. In fairness, the `generator` version implements an input range whereas the others are forward ranges. The range-v3 example can even be made random access with the addition of just three more lines. Conversely, a `generator` could never implement a stronger traversal than input since coroutine frames are uncopyable. The utilities range-v3 provides for range authoring are more flexible than `generator`s, but the conciseness of the `generator` is unbeatable for use cases for which a single-pass range suffices.

### Proposal

We propose a class template `generator`, specializations of which shall be returned by coroutine generators. `generator` has two type parameters: the intended reference type of the range it generates, and the intended value type of the range. This choice differs from earlier `generator` examples in the coroutine proposals () which were parameterized only on the value type of the generated range, but it is more general in that it can model more kinds of ranges including ranges with proxy reference types.

###

[LWG 3016](https://cplusplus.github.io/LWG/issue3016) proposes adding the phrase:

> It is implementation-defined whether over-aligned types are supported (6.6.5 [[basic.align]](http://eel.is/c++draft/basic.align)).

to the specification of `std::optional` in [[optional.optional]/1](http://eel.is/c++draft/optional.optional#1). This proposal:
* provides rationale for why the change proposed by LWG 3016 is redundant,
* proposes closing LWG 3016 as NAD, and
* proposes removing similar redundant wording from the Standard Library specification.

## Discussion

Absent explicit specification otherwise, it's reasonable to assume that the requirements of the core language apply to entities specified in the Standard Library. Specifically, the requirements in [[basic.align]](http://eel.is/c++draft/basic.align) apply to the library portions of the standard. Hence, given the specification of a class template `S`:
```c++
template <class T>
struct S {
    T internal; // exposition only
};
```
There is no need to explicitly specify that [[basic.align]/3](http://eel.is/c++draft/basic.align#3) applies to "internal": if `T` is an over-aligned type, then support for `S<T>` is implementation-defined. Similarly, the specification of `optional<T>` in [[optional.optional]/1](http://eel.is/c++draft/optional.optional#1):

> ... When an instance of `optional<T>` *contains a value*, it means that an object of type `T`, referred to as the optional object’s contained value, is allocated within the storage of the optional object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a region of the `optional<T>` storage suitably aligned for the type `T`. ...

says that the contained value is "suitably aligned" for the type `T`. Albeit the term "suitably aligned" is not specified, I believe the only reasonable interpretation is that the contained value is aligned accordingly for a subobject of type `T` - just as in the first case of an exposition-only member - in an implementation-defined manner in accordance with [[basic.align]/3](http://eel.is/c++draft/basic.align#3).

Adding redundant text to [[optional.optional]/1](http://eel.is/c++draft/optional.optional#1) would obviously not improve the quality of the Standard; if LWG agrees with the rationale provided herein, then LWG3016 should be closed as NAD.

### Alternative

If LWG feels that the above interpretation is too subtle to be left implicit, we could add blanket wording in Clause 20 to cover the entire library rather than annotating each individual instance of a library component that may create instances of a user-defined type with a cross-reference to [[basic.align]](http://eel.is/c++draft/basic.align). That requirement could take the form of a new paragraph at the end of Clause 20 (immediately after [[lib.types.movedfrom]](http://eel.is/c++draft/lib.types.movedfrom)):

> 20.5.5.?? Alignment of program-defined types [lib.types.alignment]
>
> 1 [Note: Some library components allocate instances of program-defined object types, either within the storage of an instance of a library-defined object type, or dynamically. The extent to which over-alignment of such program-defined object instances is supported is implementation-defined ([[basic.align]](http://eel.is/c++draft/basic.align)). --end note]

The author feels that such a note does not add significant value; it is presented here only to make LWG aware of the alternative.

## Technical Specifications

In addition to closing LWG 3016 as NAD, it behooves us to remove similar redundant wording from the rest of the Standard Library specification. Wording relative to [N4713](https://wg21.link/n4713).

Change [[variant.variant]/1](http://eel.is/c++draft/variant.variant#1) as follows:

> 1 Any instance of `variant` at any given time either holds a value of one of its alternative types, or it holds no
> value. When an instance of `variant` holds a value of alternative type `T`, it means that a value of type `T`,
> referred to as the `variant` object’s *contained value*, is allocated within the storage of the `variant` object.
> Implementations are not permitted to use additional storage, such as dynamic memory, to allocate the
> contained value. The contained value shall be allocated in a region of the `variant` storage suitably aligned
> for all types in `Types...`. <del>It is implementation-defined whether over-aligned types are supported.</del>

Change [[meta.trans.other]](http://eel.is/c++draft/meta.trans.other) as follows (Note that striking this sentence also resolves [Editorial issue #1757](https://github.com/cplusplus/draft/issues/1757) which is currently assigned LWG status):
> [...]
>
> 2 <del>It is implementation-defined whether any extended alignment is supported ([[basic.align]](http://eel.is/c++draft/basic.align)).</del>
>
> [...]

Change [[depr.temporary.buffer]](http://eel.is/c++draft/depr.temporary.buffer) as follows:

> [...]
>
> 2 *Effects:* Obtains a pointer to uninitialized, contiguous storage for `N` adjacent objects of type `T`, for some non-negative number `N`. <del>It is implementation-defined whether over-aligned types are supported (6.6.5).</del>

Change [[depr.default.allocator]](http://eel.is/c++draft/depr.default.allocator) as follows (Note: this makes the specification of the deprecated `allocator::allocate(size_t, const void*)` overload consistent with the non-deprecated `allocator::allocate(size_t)` overload):

> [...]
>
> 3 *Returns:* A pointer to the initial element of an array of storage of size `n * sizeof(T)`, aligned appropriately for objects of type `T`. <del>It is implementation-defined whether over-aligned types are supported ([[basic.align]](http://eel.is/c++draft/basic.align)).</del>
>
> 4 *Remarks:* The storage is obtained by calling `​::​operator new`<del>`(std​::​size_­t)`</del> ([[new.delete]](http://eel.is/c++draft/new.delete)), but it is unspecified when or how often this function is called.
